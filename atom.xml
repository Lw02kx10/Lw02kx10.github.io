<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wen&#39;s blog</title>
  
  
  <link href="https://lw02kx10.github.io/atom.xml" rel="self"/>
  
  <link href="https://lw02kx10.github.io/"/>
  <updated>2023-02-23T09:29:42.775Z</updated>
  <id>https://lw02kx10.github.io/</id>
  
  <author>
    <name>Wen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pytorch深度学习</title>
    <link href="https://lw02kx10.github.io/2023/02/22/Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lw02kx10.github.io/2023/02/22/Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-22T09:45:12.000Z</published>
    <updated>2023-02-23T09:29:42.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置安装知识"><a href="#前置安装知识" class="headerlink" title="前置安装知识"></a>前置安装知识</h2><p>使用<code>conda</code>进行安装，可以考虑使用虚拟环境。原因：<strong>python</strong>的包之间有相互依赖性，比如新装的B包需要A包的1.6，而已有的D包需要A包的2.2，如果统一使用base环境，那么就会发生冲突。</p><p>创建一个名为torchenv并且指定python版本为3.9的虚拟环境：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create <span class="literal">--name</span> torchenv python=<span class="number">3.9</span></span><br></pre></td></tr></table></figure><p>然后使用<strong>conda activate torchenv</strong> 激活环境。</p><p>除安装<strong>torch</strong>以外，还可以安装torchvision，Jupyter等。</p><span id="more"></span><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>机器学习所用基本数据结构就是<strong>n维矩阵</strong>，其中RGB图片一般是三维，视频是五维。</p><p>切片操作同<strong>numpy</strong>是相同的，还有一个需要注意的<code>a[::3,::2]</code>表示行每隔3个取1个，列是每隔2个取1个。</p><p>相同维度的张量也有<strong>广播机制</strong>，是从numpy那里继承来的。</p><h4 id="一些数据操作函数"><a href="#一些数据操作函数" class="headerlink" title="一些数据操作函数"></a>一些数据操作函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成一维向量</span></span><br><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line"><span class="comment">#取出形状或其中元素数量</span></span><br><span class="line">x.shape</span><br><span class="line">x.numel()</span><br><span class="line"><span class="comment">#改变形状</span></span><br><span class="line">x.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">#生成全0矩阵或者全1矩阵</span></span><br><span class="line">torch.zeros((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">torch.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">#将列表转换为张量（这里的列表也可以放numpy形式的矩阵）</span></span><br><span class="line">torch.tensor([[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment">#合并张量(第一个是按行合并，第二个按列合并)</span></span><br><span class="line">torch.cat((x,y),dim=<span class="number">0</span>)</span><br><span class="line">torch.cat((x,y),dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#所有元素求和（可以指定维度，如果不想丢掉维度，需要加参数keepdims=True）</span></span><br><span class="line">x.<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment">#求前缀和（可以指定维度）</span></span><br><span class="line">x.cumsum()</span><br><span class="line"><span class="comment">#为了节省内存，可能需要执行原地操作</span></span><br><span class="line">y = torch.zeros_like(x)</span><br><span class="line">y = y + x <span class="comment">#错</span></span><br><span class="line">y += x <span class="comment">#对</span></span><br><span class="line">y[:] = y + x <span class="comment">#对</span></span><br><span class="line"><span class="comment">#直接进行赋值，则是变换指针，指向内存不变</span></span><br><span class="line">y = x</span><br><span class="line">y = x.clone() <span class="comment">#使用这个，可以重新分配内存，这样y和x指向不同的空间</span></span><br><span class="line"><span class="comment">#张量转换为numpy</span></span><br><span class="line">x.numpy()</span><br><span class="line"><span class="comment">#只有1个元素的标量取出它的python数据类型值</span></span><br><span class="line">x.item()</span><br></pre></td></tr></table></figure><h4 id="数据读入及预处理"><a href="#数据读入及预处理" class="headerlink" title="数据读入及预处理"></a>数据读入及预处理</h4><p>数据的读入和写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   x = f.readlines()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;a,b,c\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>预处理可以使用<strong>pandas</strong>库，<code>data = pd.read_csv(x)</code></p><p>数据清洗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数值类型上可通过插值的方法来填补None</span></span><br><span class="line">inputs, outputs = pd.iloc[:,<span class="number">0</span>:<span class="number">2</span>], pd.iloc[:,<span class="number">2</span>]</span><br><span class="line">inputs = pd.fillna(inputs.mean())</span><br><span class="line"></span><br><span class="line"><span class="comment">#对于非数值类型的可以将是否为None作为新的一列</span></span><br><span class="line">inputs = pd.get_dummies(inputs,dummy_na=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#接着我们就可以将新数据转换为张量形式了</span></span><br><span class="line">inputs = torch.tensor(inputs.values, dtype=torch.float32)</span><br><span class="line"><span class="comment">#默认是float64，不过深度学习一般用float32，因为float64运算速度太慢了</span></span><br></pre></td></tr></table></figure><h2 id="线性代数知识"><a href="#线性代数知识" class="headerlink" title="线性代数知识"></a>线性代数知识</h2><p>两个向量是<strong>正交的</strong>，即他们的点乘是等于0的。</p><p>我们常用Frobenius范数来表示矩阵的长度，做法是把矩阵拉长为一条线，然后再计算<strong>其平方求和开根号</strong>。</p><p>矩阵的乘法会改变形状，而<strong>不被矩阵改变方向</strong>的向量被称为<strong>特征向量</strong>。对称矩阵总是可以找到特征向量的。</p><h4 id="线性代数操作函数"><a href="#线性代数操作函数" class="headerlink" title="线性代数操作函数"></a>线性代数操作函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#矩阵乘法</span></span><br><span class="line">torch.dot(x,y)</span><br><span class="line"><span class="comment">#向量点积做法</span></span><br><span class="line">torch.<span class="built_in">sum</span>(x*y)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前置安装知识&quot;&gt;&lt;a href=&quot;#前置安装知识&quot; class=&quot;headerlink&quot; title=&quot;前置安装知识&quot;&gt;&lt;/a&gt;前置安装知识&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;conda&lt;/code&gt;进行安装，可以考虑使用虚拟环境。原因：&lt;strong&gt;python&lt;/strong&gt;的包之间有相互依赖性，比如新装的B包需要A包的1.6，而已有的D包需要A包的2.2，如果统一使用base环境，那么就会发生冲突。&lt;/p&gt;
&lt;p&gt;创建一个名为torchenv并且指定python版本为3.9的虚拟环境：&lt;/p&gt;
&lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conda create &lt;span class=&quot;literal&quot;&gt;--name&lt;/span&gt; torchenv python=&lt;span class=&quot;number&quot;&gt;3.9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后使用&lt;strong&gt;conda activate torchenv&lt;/strong&gt; 激活环境。&lt;/p&gt;
&lt;p&gt;除安装&lt;strong&gt;torch&lt;/strong&gt;以外，还可以安装torchvision，Jupyter等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://lw02kx10.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python数据分析与计算</title>
    <link href="https://lw02kx10.github.io/2023/01/24/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/"/>
    <id>https://lw02kx10.github.io/2023/01/24/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/</id>
    <published>2023-01-24T09:57:21.000Z</published>
    <updated>2023-01-25T08:14:35.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p><strong>numpy</strong>生成的数组，是一种应该称为<strong>多维矩阵</strong>。底层使用<strong>c语言</strong>编写，在进行数值运算、线性代数运算时速度很快。</p><blockquote><p>不使用<strong>python</strong>原生的列表是因为其列表中的元素可以是<strong>任意对象</strong>，因此列表中所保存的是对象的指针，这样的话保存3个数值元素就需要3个指针加上3个数值对象，对于数值计算来说，这种结构显然比较浪费内存和CPU的计算时间。</p></blockquote><p>运用一些np数组的属性，可以获得这个np数组的一些信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#几维矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr.ndim)</span><br><span class="line"><span class="comment">#形状（以元组形式给出）</span></span><br><span class="line"><span class="built_in">print</span>(arr.shape)</span><br><span class="line"><span class="comment">#总元素个数</span></span><br><span class="line"><span class="built_in">print</span>(arr.size)</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h3><p>numpy可以使用以下几种常用的方式来创建数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用原生python列表生成</span></span><br><span class="line">np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment">#[start,end)生成数据，可以使用reshape方法进行shape调整</span></span><br><span class="line">np.arange(start,end,step=<span class="literal">None</span>,dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#[start,end]以等差数列形式生成数据</span></span><br><span class="line">np.linspace(start,end,num=<span class="number">50</span>)</span><br><span class="line"><span class="comment">#[base^start,base^end]以等比数列形式</span></span><br><span class="line">np.logspace(start,end,num=<span class="number">50</span>,base=<span class="number">10</span>)</span><br><span class="line"><span class="comment">#全是1，默认是float64类型的，可以使用b = a.astype(int32)来转换数据类型</span></span><br><span class="line">np.ones((x,y))</span><br><span class="line"><span class="comment">#全是0</span></span><br><span class="line">np.zeros((x,y))</span><br><span class="line"><span class="comment">#和a的shape相同并且全是0</span></span><br><span class="line">np.zeros_like(a)</span><br><span class="line"><span class="comment">#生成n阶单位矩阵</span></span><br><span class="line">np.eye(n)</span><br><span class="line"><span class="comment">#生成第k对角线为1，其他为0的n阶方阵</span></span><br><span class="line">np.eye(n,k)</span><br><span class="line"><span class="comment">#运用笛卡尔积生成网格点</span></span><br><span class="line">x,y = np.meshgrid(a,b)</span><br><span class="line"><span class="comment">#np.mgrid[起始值:结束值:步长,起始值:结束值:步长,...]</span></span><br><span class="line"><span class="comment">#生成网格,[起始值,结束值)，这种方法常用在机器学习中生成数据</span></span><br><span class="line">x,y = np.mgrid[<span class="number">1</span>:<span class="number">3</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">4</span>:<span class="number">0.5</span>] <span class="comment">#前者生成两个数，后者生成四个数，所以x和y都为两行四列</span></span><br><span class="line">x = x.ravel() <span class="comment">#将多维数组变为一维数组，类似于flatten方法</span></span><br><span class="line">y = y.ravel()</span><br><span class="line"><span class="comment">#将两数组对应的值分别配对，类似于普通python中的zip方法</span></span><br><span class="line">grid = np.c_[x,y]</span><br><span class="line"><span class="comment">#运算random库随机生成数据</span></span><br><span class="line">np.random.random((<span class="number">2</span>,<span class="number">4</span>)) <span class="comment">#[0,1)的随机数</span></span><br><span class="line"><span class="comment">#或者先设置随机数种子</span></span><br><span class="line">rdm = np.random.RandomState(seed) <span class="comment">#设置随机数种子</span></span><br><span class="line">a = rdm.rand() <span class="comment">#返回标量</span></span><br><span class="line">b = rdm.rand(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#2行3列的随机数矩阵</span></span><br></pre></td></tr></table></figure><h3 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"><span class="built_in">print</span>(a[a&gt;<span class="number">7</span>]) <span class="comment">#[8,9,10,11,12]</span></span><br><span class="line">condition = a &gt; <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(np.where(condition,-<span class="number">1</span>,a)) <span class="comment">#符合condition的替换为-1，不符合的仍然是a中的数</span></span><br><span class="line"><span class="built_in">print</span>(np.where(condition,a,<span class="number">2</span>))</span><br><span class="line">b = -a-<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(np.where(condition,a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment">#所有小于5的数变成5，所有大于9的数变成9，中间的数保留</span></span><br><span class="line">np.clip(a,<span class="number">5</span>,<span class="number">9</span>)</span><br></pre></td></tr></table></figure><h3 id="数组的计算"><a href="#数组的计算" class="headerlink" title="数组的计算"></a>数组的计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line">np.transport(a) <span class="comment">#求a的转置矩阵</span></span><br><span class="line">a.T <span class="comment">#同上</span></span><br><span class="line"><span class="comment">#以下分别是加减乘操作</span></span><br><span class="line">c = a+b</span><br><span class="line">c = a-b</span><br><span class="line">c = a*b  <span class="comment">#这个乘法并不是矩阵乘法，而是逐个相乘</span></span><br><span class="line">c = b**<span class="number">2</span></span><br><span class="line">c = <span class="number">10</span>*np.sin(a) <span class="comment">#对a中的每个数求sin然后乘以10</span></span><br><span class="line">c = np.dot(a,b) <span class="comment">#矩阵乘法</span></span><br><span class="line">c = a.dot(b) <span class="comment">#同上</span></span><br><span class="line">c = a @ b <span class="comment">#这时候b会被转置一下</span></span><br><span class="line"><span class="built_in">print</span>(b&lt;<span class="number">3</span>)  <span class="comment">#[True,True,True,False]</span></span><br><span class="line">np.inner(a) <span class="comment">#算矩阵内积</span></span><br><span class="line">np.outer(a) <span class="comment">#算矩阵外积</span></span><br></pre></td></tr></table></figure><h3 id="合并与分割"><a href="#合并与分割" class="headerlink" title="合并与分割"></a>合并与分割</h3><p><code>np.vstack(a,b)</code>表示<strong>上下合并</strong>，<code>np.hstack(a,b)</code>表示<strong>左右合并</strong>。</p><p><code>np.vsplit(a,m)</code>表示将a分为m个<strong>行数组</strong>，<code>np.hsplit(a,m)</code>表示将a分为m个<strong>列数组</strong>。</p><p>其实这里的v就是单词<strong>vertical</strong>，也就是<strong>垂直的</strong>意思，而h就是单词<strong>horizon</strong>。</p><h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认按行打印</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#打印列</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> a.T:</span><br><span class="line">    <span class="built_in">print</span>(col)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将矩阵展开成一个一维数组</span></span><br><span class="line"><span class="built_in">print</span>(a.flatten())</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a.flat: <span class="comment">#将返回一个一维数组迭代器，打印每一个元素</span></span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><h3 id="线性代数运算"><a href="#线性代数运算" class="headerlink" title="线性代数运算"></a>线性代数运算</h3><p><strong>python</strong>中的线性代数运算主要使用<code>numpy.linalg</code>模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#求范数,ord表示范数的种类</span></span><br><span class="line">np.linalg.norm(x,<span class="built_in">ord</span>=<span class="literal">None</span>,axis=<span class="literal">None</span>,keepdims=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#求逆矩阵</span></span><br><span class="line">np.linalg.inv(a)</span><br><span class="line"><span class="comment">#求矩阵的行列式</span></span><br><span class="line">np.linalg.det(a)</span><br><span class="line"><span class="comment">#求解线性方程组</span></span><br><span class="line">np.linalg.solve(a,b)</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>在将一个np矩阵赋值给某个变量时，这个变量是一个<strong>指针</strong>，如果再将这个变量赋给另外一个变量，那么这两个变量指向的将是同一块内存空间，可以使用<code>b = a.copy()</code>进行复制。</p><p><code>np.ceil()</code>和<code>np.floor()</code>函数都用于取整，还有一个<code>np.round(a,4)</code>表示对数据进行<strong>四舍五入</strong>，这里是保留四位小数。</p><p>如果想要旋转某个矩阵，可以使用<code>np.rot90(a)</code>这个函数，可以<strong>逆时针</strong>旋转矩阵90度。</p><h2 id="Scipy"><a href="#Scipy" class="headerlink" title="Scipy"></a>Scipy</h2><p><strong>Scipy</strong>是在<strong>Numpy</strong>的基础上增加了众多的数学，科学以及工程计算中常用的函数库。其依赖于<strong>Numpy</strong>，提供了便捷且快速的n维数组操场。其涉及很多模块，功能强大。</p><h3 id="求解非线性方程（组）"><a href="#求解非线性方程（组）" class="headerlink" title="求解非线性方程（组）"></a>求解非线性方程（组）</h3><p>使用<strong>scipy.optimize</strong>模块中的<strong>fsolve</strong>，<strong>root</strong>可以求解非线性方程（组）的解。比如说求解如下方程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> fsolve,root</span><br><span class="line">fx = <span class="keyword">lambda</span> x: [x[<span class="number">0</span>]**<span class="number">2</span>+x[<span class="number">1</span>]**<span class="number">2</span>-<span class="number">1</span>, x[<span class="number">0</span>]-x[<span class="number">1</span>]]</span><br><span class="line"><span class="comment">#第二个参数表示在哪个位置附近求根，maxfev表示函数的调用次数，调用次数越多就越精确</span></span><br><span class="line">x1 = fsolve(fx,[<span class="number">1</span>,<span class="number">1</span>],maxfev=<span class="number">4000</span>)</span><br><span class="line">x2 = root(fx,[<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="求积分"><a href="#求积分" class="headerlink" title="求积分"></a>求积分</h3><p>使用<strong>scipy.integrate</strong>模块来求积分，其中给定了一些方法来帮助我们求积分:<strong>quad,dblquad,tplquad,nquad</strong>。他们分别对应一重积分，二重积分，三重积分和多重积分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> quad</span><br><span class="line"><span class="comment">#先定义被积函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x,a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*x**<span class="number">2</span> + b*x</span><br><span class="line"><span class="comment">#第一个参数表示被积函数，第二、三个参数分别表示积分下、上限，第四个表示传入参数a和b的值</span></span><br><span class="line">I1 = quad(fun,<span class="number">0</span>,<span class="number">1</span>,args(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">I2 = quad(fun,<span class="number">0</span>,<span class="number">1</span>,args(<span class="number">2</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="求最小二乘解"><a href="#求最小二乘解" class="headerlink" title="求最小二乘解"></a>求最小二乘解</h3><blockquote><p> 在线性方程的求解或是数据曲线拟合中，利用 <strong>最小二乘法 求得的解</strong>则被称为最小二乘解。 最小二乘法（又称<strong>最小平方法</strong>）是一种数学优化技术，它通过<strong>最小化误差的平方和</strong>寻找数据的<strong>最佳函数匹配</strong>。 </p></blockquote><h2 id="Sympy"><a href="#Sympy" class="headerlink" title="Sympy"></a>Sympy</h2><p>用于进行<strong>符号运算</strong>，可以对表达式进行<strong>因式分解，化简，微分，积分，解代数方程，求解常微分方程</strong>。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line"><span class="comment">#定义符号变量x y z</span></span><br><span class="line">x,y,z = sp.symbols(<span class="string">&#x27;x y z&#x27;</span>)</span><br><span class="line"><span class="comment">#同上，最好使用上面那个，使用var会报莫名的错误</span></span><br><span class="line">sp.var(<span class="string">&#x27;x y z&#x27;</span>)</span><br><span class="line"><span class="comment">#定义多个符号函数</span></span><br><span class="line">f,g = sp.symbols(<span class="string">&#x27;f g&#x27;</span>,cls=sp.Function)</span><br><span class="line">sp.var(<span class="string">&#x27;f g&#x27;</span>,cls=fp.Function)</span><br><span class="line"><span class="comment">#定义符号函数</span></span><br><span class="line">y = sp.Function(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="comment">#----------------------------------</span></span><br><span class="line"><span class="comment">#解方程ax^2 + bx + c = 0, 其中x为未知数</span></span><br><span class="line">sp.var(<span class="string">&#x27;a b c x&#x27;</span>)</span><br><span class="line"><span class="comment">#solve函数求解符号代数方程或方程组,第一个参数表示要解的方程，第二个参数表示未知数是谁</span></span><br><span class="line">x0 = sp.solve(a*x**<span class="number">2</span>+b*x+c,x) </span><br><span class="line"><span class="built_in">print</span>(x0)</span><br><span class="line"><span class="comment">#----------------------------------</span></span><br><span class="line"><span class="comment">#解联立方程组，方程组和未知数以数组的形式给出</span></span><br><span class="line">(<span class="number">1</span>)x1^<span class="number">2</span> + x2^<span class="number">2</span> = <span class="number">1</span>; (<span class="number">2</span>)x1=x2</span><br><span class="line">sp.var(<span class="string">&#x27;x1,x2&#x27;</span>)</span><br><span class="line">s = sp.solve([x1**<span class="number">2</span>+x2**<span class="number">2</span>-<span class="number">1</span>,x1-x2],[x1,x2])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以使用符号数组的方法</span></span><br><span class="line"><span class="comment">#定义符号变量数组x，里面存两个变量</span></span><br><span class="line">x = sp.var(<span class="string">&#x27;x:2&#x27;</span>)</span><br><span class="line">s = sp.solve([x[<span class="number">0</span>]**<span class="number">2</span>+x[<span class="number">1</span>]**<span class="number">2</span>-<span class="number">1</span>,x[<span class="number">0</span>]-x[<span class="number">1</span>]],x)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="comment">#----------------------------------</span></span><br><span class="line"><span class="comment">#处理分数等有理数时使用Rational可以避免出现累积误差</span></span><br><span class="line">r1 = sp.Rational(<span class="number">1</span>/<span class="number">10</span>)</span><br><span class="line">r2 = sp.Rational(<span class="number">1</span>/<span class="number">10</span>)</span><br><span class="line">r3 = sp.Rational(<span class="number">1</span>/<span class="number">10</span>)</span><br><span class="line">val = (r1 + r2 + r3) * <span class="number">3</span></span><br><span class="line"><span class="comment">#注意，要使用evalf()来显示值</span></span><br><span class="line"><span class="built_in">print</span>(val.evalf())</span><br><span class="line"><span class="comment">#----------------------------------</span></span><br><span class="line"><span class="comment">#格式化输出</span></span><br><span class="line">a,b,c,x = sp.symbols(<span class="string">&#x27;a,b,c,x&#x27;</span>)</span><br><span class="line">x0 = sp.solve(a*x**<span class="number">2</span>+b*x+c,x)</span><br><span class="line"><span class="comment">#使用pprint即可格式化输出到控制台</span></span><br><span class="line">sp.pprint(x0)</span><br><span class="line"><span class="comment">#----------------------------------</span></span><br><span class="line"><span class="comment">#比较两个表达式是否相等</span></span><br><span class="line">x = sp.symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">a = sp.cos(x)**<span class="number">2</span> - sp.sin(x)**<span class="number">2</span></span><br><span class="line">b = sp.cos(<span class="number">2</span>*x)</span><br><span class="line"><span class="comment">#判断两个表达式是否相等，不能使用==，只能使用equals函数</span></span><br><span class="line"><span class="built_in">print</span>(a.equals(b))</span><br><span class="line"><span class="comment">#----------------------------------</span></span><br><span class="line"><span class="comment">#简化表达式</span></span><br><span class="line">expr = sp.sin(x)/sp.cos(x)</span><br><span class="line"><span class="comment">#simplify函数用于简化表达式，将表达式更改为更简单的形式</span></span><br><span class="line">sp.pprint(sp.simplify(expr))</span><br><span class="line"><span class="comment">#----------------------------------</span></span><br><span class="line"><span class="comment">#求导函数（也可以用于求偏导）</span></span><br><span class="line"><span class="comment">#func是要求导的函数，x是要求导的变量，n是可选的，表示求n阶导数，默认为1阶导数</span></span><br><span class="line">diff(func,x,n)</span><br><span class="line"><span class="comment">#或者用func.diff(x)的方法调用</span></span><br><span class="line">f = sp.Function(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">sp.var(<span class="string">&#x27;a b c x y&#x27;</span>)</span><br><span class="line">u = f(x,y); ux = u.diff(x); uy = u.diff(y)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Numpy&quot;&gt;&lt;a href=&quot;#Numpy&quot; class=&quot;headerlink&quot; title=&quot;Numpy&quot;&gt;&lt;/a&gt;Numpy&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;numpy&lt;/strong&gt;生成的数组，是一种应该称为&lt;strong&gt;多维矩阵&lt;/strong&gt;。底层使用&lt;strong&gt;c语言&lt;/strong&gt;编写，在进行数值运算、线性代数运算时速度很快。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不使用&lt;strong&gt;python&lt;/strong&gt;原生的列表是因为其列表中的元素可以是&lt;strong&gt;任意对象&lt;/strong&gt;，因此列表中所保存的是对象的指针，这样的话保存3个数值元素就需要3个指针加上3个数值对象，对于数值计算来说，这种结构显然比较浪费内存和CPU的计算时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运用一些np数组的属性，可以获得这个np数组的一些信息：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#几维矩阵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.ndim)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#形状（以元组形式给出）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.shape)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#总元素个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(arr.size)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://lw02kx10.github.io/tags/python/"/>
    
    <category term="learn" scheme="https://lw02kx10.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib数据可视化</title>
    <link href="https://lw02kx10.github.io/2023/01/23/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://lw02kx10.github.io/2023/01/23/Matplotlib%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2023-01-23T12:30:48.000Z</published>
    <updated>2023-01-24T09:42:09.485Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Matplotlib</strong>是<strong>python</strong>的一个绘图库，可以实现<strong>函数图像、散点图、网格图、柱状图、饼状图、直方图</strong>等等。不仅可以实现二维绘图，还可以实现三维绘图。</p><p>如<strong>函数图</strong>使用<code>ax.plot()</code>，<strong>散点图</strong>使用<code>ax.scatter()</code>，<strong>柱状图</strong>使用<code>ax.bar()</code>，<strong>水平条形图</strong>使用<code>ax.barh(y,x)</code>，<strong>饼状图</strong>使用<code>ax.pie(content,label)</code>，<strong>直方图</strong>使用<code>ax.hist()</code>。</p><p>以下内容学习<a href="https://matplotlib.org/">https://matplotlib.org/</a> 官网所做笔记。</p><h2 id="引入pyplot的绘图基本使用"><a href="#引入pyplot的绘图基本使用" class="headerlink" title="引入pyplot的绘图基本使用"></a>引入pyplot的绘图基本使用</h2><p>如果只需要在<strong>figure</strong>中画一个图（axes），那就可以不使用<code>plt.subplots</code>的方法，而是直接使用<code>plt</code>，将其作为一个axes。不过直接使用<code>plt</code>，和使用<code>plt.subplots</code>返回的axes对象，两者的一些语法略有不同。</p><span id="more"></span><h3 id="plt-plot方法"><a href="#plt-plot方法" class="headerlink" title="plt.plot方法"></a>plt.plot方法</h3><p>这个方法本身会返回一个<strong>图线对象列表</strong>，可以用它来操作一些图线属性，如：<code>lines = plt.plot(x1,y1,x2,y2)</code>。</p><p>在<code>plt.plot([1,2,3,4],[3,4,5,6],&#39;ro&#39;)</code>中传入的<strong>第三个参数</strong>用来格式化，调节样式，比如默认样式是蓝色直线，这里用‘ro’改成了是红色的点。</p><p>同时我们也可以传入<strong>多个参数</strong>，<code>plt.plot(t,t,&#39;r--&#39;,t,t**2,&#39;bs&#39;,t,t**3,&#39;g^&#39;)</code>这样将会在一个axes中画出多个函数曲线。</p><p>这个方法还有一些样式参数，如<code>linewidth</code>，<code>alpha</code>，<code>marker</code>等等。</p><h3 id="使用plt-subplot"><a href="#使用plt-subplot" class="headerlink" title="使用plt.subplot"></a>使用plt.subplot</h3><p><code>plt.subplot(xyz)</code>方法有如<code>plt.subplots</code>的作用，可以在一张画布上画多个图像，其中参数<strong>xyz</strong>是一个整体，<strong>x表示共有几行，y表示共有几列，z表示当前所处第几个图像的位置</strong>。如果<strong>x*y</strong>大于10了，那么就需要在参数之间加上逗号。</p><p>由于z是动态变化的，所以要用完一次<strong>subplot</strong>之后就立刻画出图像，然后接着画下一幅。</p><h3 id="设置axes属性的plt方法"><a href="#设置axes属性的plt方法" class="headerlink" title="设置axes属性的plt方法"></a>设置axes属性的plt方法</h3><p><code>plt.xlabel(&#39;xlabel&#39;)</code>用来设置x轴的名字，y轴也是同理。有<strong>fontsize</strong>，<strong>color</strong>等一些属性。</p><p><code>plt.axis([xmin,xmax,ymin,ymax])</code>用来同时设置两个轴的取值范围。</p><p><code>plt.suptitle()</code>为图像设置一个居中<strong>主标题</strong>，注意与<code>plt.title()</code>方法的区别，后者是设置图像的子标题，可以设置在左中右三个位置，还可以指定y坐标，如：<code>plt.title(&#39;text content&#39;,y=1,loc=&#39;left&#39;)</code>表示在y&#x3D;1的位置，图像的左部设置一个子标题。</p><p><code>plt.setp</code>是一个很万能的方法，可以设置图线的很多属性，需要传入一个图线列表，如：<code>plt.setp(lines,color=&#39;r&#39;,linewidth=2.0)</code></p><p><code>plt.grid(True)</code>可以设置打开图像网格。</p><p>如果想要在图像中，或者坐标轴上显示汉字，则需要使用<code>plt.rc()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, family=<span class="string">&#x27;SimHei&#x27;</span>) <span class="comment">#设置正常显示中文</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, size=<span class="number">16</span>) <span class="comment">#设置文字大小</span></span><br><span class="line">plt.rc(<span class="string">&#x27;axes&#x27;</span>, unicode_minus=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><code>plt.text(x,y,r&#39;$\mu=100,\sigma=15$&#39;)</code>用来在图像上加注解文字，同时这里也提供了一种<strong>格式化数学符号</strong>的方法。</p><p><code>plt.annotate</code>方法类似于上者，可以<strong>为某点添加注解，并且用箭头指明</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所标记的点为(2,1),文字内容所在位置为(3,1.5)</span></span><br><span class="line">plt.annotate(<span class="string">&#x27;text content&#x27;</span>,xy=(<span class="number">2</span>,<span class="number">1</span>),xytext(<span class="number">3</span>,<span class="number">1.5</span>),arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>,shrink=<span class="number">0.05</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="使用subplots"><a href="#使用subplots" class="headerlink" title="使用subplots"></a>使用subplots</h2><p>使用<strong>subplots</strong>方法时，要先创建<strong>axes</strong>对象，<code>fig, ax = plt.subplots()</code>，参数中可以传入<strong>行和列</strong>，表示要在一个figure上创建几个axes。在获取到axes对象后，直接使用<code>ax.plot()</code>进行绘图即可。</p><p>对于整个figure的结构分布，有如下一图（引用自<strong>matplotlib</strong>官网）：</p><p> <img src="https://matplotlib.org/stable/_images/anatomy.png" alt="结构分布"> </p><p>注意legend方法，使用之前需要在每次plot的时候传入一个label参数，然后再用<code>ax.legend()</code>进行显现。</p><h2 id="三维绘图"><a href="#三维绘图" class="headerlink" title="三维绘图"></a>三维绘图</h2><p>在三维绘图之前，需要使用<code>ax = plt.axes(projection=&#39;3d&#39;)</code>来<strong>设置三维图形模式</strong></p><p>正常使用<code>ax.plot</code>画出来的三维图像可能是一个<strong>三维曲线</strong>，如果想要把三维曲线变成三维曲面，则需要使用<code>ax.plot_surface()</code>方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Matplotlib&lt;/strong&gt;是&lt;strong&gt;python&lt;/strong&gt;的一个绘图库，可以实现&lt;strong&gt;函数图像、散点图、网格图、柱状图、饼状图、直方图&lt;/strong&gt;等等。不仅可以实现二维绘图，还可以实现三维绘图。&lt;/p&gt;
&lt;p&gt;如&lt;strong&gt;函数图&lt;/strong&gt;使用&lt;code&gt;ax.plot()&lt;/code&gt;，&lt;strong&gt;散点图&lt;/strong&gt;使用&lt;code&gt;ax.scatter()&lt;/code&gt;，&lt;strong&gt;柱状图&lt;/strong&gt;使用&lt;code&gt;ax.bar()&lt;/code&gt;，&lt;strong&gt;水平条形图&lt;/strong&gt;使用&lt;code&gt;ax.barh(y,x)&lt;/code&gt;，&lt;strong&gt;饼状图&lt;/strong&gt;使用&lt;code&gt;ax.pie(content,label)&lt;/code&gt;，&lt;strong&gt;直方图&lt;/strong&gt;使用&lt;code&gt;ax.hist()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下内容学习&lt;a href=&quot;https://matplotlib.org/&quot;&gt;https://matplotlib.org/&lt;/a&gt; 官网所做笔记。&lt;/p&gt;
&lt;h2 id=&quot;引入pyplot的绘图基本使用&quot;&gt;&lt;a href=&quot;#引入pyplot的绘图基本使用&quot; class=&quot;headerlink&quot; title=&quot;引入pyplot的绘图基本使用&quot;&gt;&lt;/a&gt;引入pyplot的绘图基本使用&lt;/h2&gt;&lt;p&gt;如果只需要在&lt;strong&gt;figure&lt;/strong&gt;中画一个图（axes），那就可以不使用&lt;code&gt;plt.subplots&lt;/code&gt;的方法，而是直接使用&lt;code&gt;plt&lt;/code&gt;，将其作为一个axes。不过直接使用&lt;code&gt;plt&lt;/code&gt;，和使用&lt;code&gt;plt.subplots&lt;/code&gt;返回的axes对象，两者的一些语法略有不同。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://lw02kx10.github.io/tags/python/"/>
    
    <category term="learn" scheme="https://lw02kx10.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>Selenium-Webdriver</title>
    <link href="https://lw02kx10.github.io/2023/01/20/Selenium-Webdriver/"/>
    <id>https://lw02kx10.github.io/2023/01/20/Selenium-Webdriver/</id>
    <published>2023-01-20T04:09:40.000Z</published>
    <updated>2023-01-24T04:41:21.103Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Selenium</strong>用于实现网页的自动化操作，可跨浏览器使用，也可跨语言使用，在<strong>php</strong>，<strong>Java</strong>，<strong>python</strong>等多门语言中均可使用。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先需要安装<strong>selenium</strong>库，可根据<strong>python</strong>环境使用<strong>conda</strong>安装或<strong>pip</strong>安装，<code>pip install selenium</code>，安装成功后进入<strong>python</strong>交互环境，在<code>import selenium</code>没有报错的情况下，说明安装成功。</p><p>之后还需要为浏览器下载<strong>webdriver</strong>驱动，在 <a href="https://www.selenium.dev/downloads/">Downloads | Selenium</a> 中找到自己要驱动的浏览器并且下载对应的版本，版本号要与当前浏览器的版本相符，不然会出现启动浏览器后网址会只显示data;，的情况。不过也问题不大。</p><p><strong>webdriver</strong>下载好后的<strong>exe</strong>文件，可以放在自己的<strong>python</strong>安装目录下，这是省去了为<strong>webdriver</strong>配置环境变量的麻烦。</p><span id="more"></span><hr><h2 id="操作浏览器"><a href="#操作浏览器" class="headerlink" title="操作浏览器"></a>操作浏览器</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>尝试打开一个页面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment">#以Edge浏览器为例</span></span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line"><span class="comment">#使用get(url)方法来打开一个网页</span></span><br><span class="line">browser.get(<span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line"><span class="comment">#获取当前网页标题</span></span><br><span class="line"><span class="built_in">print</span>(browser.title)</span><br></pre></td></tr></table></figure><p>页面打开时并不是最大化的，如果我们想要最大化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置打开页面的长和宽</span></span><br><span class="line">browser.set_window_size(<span class="number">700</span>,<span class="number">400</span>)</span><br><span class="line"><span class="comment">#或直接使用最大化命令</span></span><br><span class="line">browser.maximize_window()</span><br></pre></td></tr></table></figure><p>实现浏览器的几个基本操作命令：<strong>前进，后退，刷新，退出</strong>。使用<strong>time</strong>时间库来给浏览器操作网页一定的时间，更符合人操作网页的样子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)  <span class="comment">#停留两秒</span></span><br><span class="line"><span class="comment">#为了避免频繁访问拖垮网站，导致IP被封等一系列问题，应该把速度放缓。</span></span><br><span class="line">browser.back()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.forward()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.refresh()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.quit() <span class="comment">#关闭浏览器</span></span><br></pre></td></tr></table></figure><p>实现拖拽窗口，和下拉滚动条， 但是调用滚动轴的相关的命令在<strong>selenium</strong>库中没有，但我们可以通过使用<strong>JavaScript</strong>的<strong>DOM</strong>操作来模拟操作。这句命令为<code>browser.execute_script([Js_DOM])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js_code = <span class="string">&quot;document.documentElement.scrollTop = 10000&quot;</span></span><br><span class="line">browser.execute_script(js_code)</span><br></pre></td></tr></table></figure><h3 id="Cookie的调用"><a href="#Cookie的调用" class="headerlink" title="Cookie的调用"></a>Cookie的调用</h3><p><strong>selenium</strong>为我们提供了以下的<strong>cookie</strong>调用方法：</p><blockquote><p><strong>get_cookies():</strong> 获得所有 cookie 信息。</p><p><strong>delete_all_cookies()：</strong>删除所有 cookie 信息。 </p><p><strong>get_cookie([name])：</strong>返回字典的 key 为[name]的 cookie 。 </p><p><strong>add_cookie(cookie_dict)：</strong>添加 cookie。“cookie_dict”指字典对象，必须有 name 和 value 两个值。 </p><p><strong>delete_cookie([name],[optionsString])：</strong>删除 cookie 信息。[name]是要删除的 cookie 的名称。第二个参数[optionsString]是 cookie 选项，目前支持的选项包括“路径”， “域”  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser.get(<span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line">cookies = browser.get_cookies()</span><br><span class="line">cookie = browser.get_cookie(<span class="string">&#x27;BAIDUID&#x27;</span>)</span><br><span class="line">browser.add_cookie(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;123&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;20&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="用JavaScript代码协助实现页面多开"><a href="#用JavaScript代码协助实现页面多开" class="headerlink" title="用JavaScript代码协助实现页面多开"></a>用JavaScript代码协助实现页面多开</h3><p>我们在日常操作浏览器中总是希望打开另外一个页面，而又舍不得关闭现在的页面。或是现在的页面依旧有他的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">browser.get(<span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入的js代码只是为一串字符串</span></span><br><span class="line">js_code = <span class="string">&quot;window.open(&#x27;https://another.com&#x27;);&quot;</span></span><br><span class="line">browser.execute_script(js_code)</span><br></pre></td></tr></table></figure><hr><h2 id="页面的HTML节点定位"><a href="#页面的HTML节点定位" class="headerlink" title="页面的HTML节点定位"></a>页面的HTML节点定位</h2><p><strong>selenium</strong>提供<code>browser.find_element(by,detail)</code>来定位节点元素，还有另外一个方法是<code>browser.find_elements(by,detail)</code>会返回一个列表，<strong>区别是前者没找到元素会抛出异常，后者没找到会返回空列表</strong>。所以如果有一个页面元素可能出现也可能不出现，则可以以这种空列表的方式判断。</p><p>如获取百度首页的输入框和搜索按钮：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用ID选择定位元素</span></span><br><span class="line">input_node = browser.find_element(By.ID,<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">submit_btn = browser.find_element(By.ID,<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line"></span><br><span class="line">input_node.send_keys(<span class="string">&quot;github&quot;</span>)</span><br><span class="line">submit_btn.click()</span><br><span class="line"><span class="comment">#注：如果页面使用的是input表单提交的，则需要使用submit()方法</span></span><br><span class="line"><span class="comment">#超链接也是使用click()方法的</span></span><br></pre></td></tr></table></figure><p>除了使用<code>By.ID</code>，还可以使用<strong>CSS_SELECTOR</strong>，<strong>XPATH</strong>，<strong>LINK_TEXT</strong>，<strong>PARTIAL_LINK_TEXT</strong>，<strong>CLASS_NAME</strong>等等。其中<strong>LINK_TEXT</strong>表示要定位某链接，这个链接的文本可以与其匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element(By.LINK_TEXT,<span class="string">&quot;新闻&quot;</span>).click()</span><br></pre></td></tr></table></figure><p>对于<strong>XPATH</strong>代码，在开发者工具中定位到页面节点后，可以直接复制<strong>XPATH</strong>代码。</p><p>如果使用<strong>CLASS_NAME</strong>定位元素，则可能会有多个匹配项，所以结果会以<strong>列表</strong>的形式返回。</p><hr><h2 id="Headless-Edge配合Selenium使用"><a href="#Headless-Edge配合Selenium使用" class="headerlink" title="Headless-Edge配合Selenium使用"></a>Headless-Edge配合Selenium使用</h2><p>一些复杂的页面使用<strong>JS</strong>渲染，有很多的后台请求，单纯的依靠分析<strong>HTML</strong>来定位较为困难。</p><p>再者，<strong>Selenium</strong>使用过程中，浏览器一页一页在我们眼前被打开，但我们希望在跑<strong>Selenium</strong>程序的时候还可以做一些其他的事情。</p><p>所以引入<strong>无头浏览器</strong>，也称<strong>无界面浏览器</strong>，不需要界面的同时也会占用更小的内存，更适用于大规模多进程爬数据。</p><p>由于我们把<strong>无头浏览器</strong>也当做一种特殊的浏览器，那么使用它的语法就和使用其他浏览器相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.edge.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment">#无界面设置，先创建配置项：</span></span><br><span class="line">edge_options = Options()</span><br><span class="line"><span class="comment">#传参进去，使用无头模式</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment">#禁用GPU，防止无头模式出现莫名的BUG</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">browser = webdriver.Edge(options=edge_options)</span><br></pre></td></tr></table></figure><p>在使用<strong>无头模式</strong>时，由于我们看不到浏览器，所以对于一些<strong>需要记录的界面</strong>，可以调用函数<code>browser.save_screenshot(&#39;pic.png&#39;)</code>来对界面截图并且保存到文件的当前目录之下。</p><hr><h2 id="延缓访问"><a href="#延缓访问" class="headerlink" title="延缓访问"></a>延缓访问</h2><p>为避免过快访问，延缓速度的方式有三种：分别是使用<code>time.sleep()</code><strong>强制等待</strong>，使用<code>browser.implicitly_wait()</code><strong>隐式等待</strong>和<strong>显式等待</strong>。隐式等待和显式等待可以同时使用，不过等待的最长时间取决两者之间的最大值。</p><p>使用隐式等待时，如：<code>browser.implicitly_wait(10)</code>。那么在下面的代码查找页面节点的时候，如果没有找到，<strong>不会立刻返回错误，而是会每隔半秒重新查找一次</strong>。</p><p>使用显式等待：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> ec</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#对browser使用，最长等待时间为10s，检查频率为0.5</span></span><br><span class="line">    <span class="comment">#ec中的方法有很多，不止presence_of_element_located一个</span></span><br><span class="line">    WebDriverWait(browser,<span class="number">10</span>,<span class="number">0.5</span>).until(ec.presence_of_element_located(By.LINK_TEXT,<span class="string">&#x27;首页&#x27;</span>),<span class="string">&quot;页面还未开放&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment">#get_attribute()方法可以获取某个标签身上属性</span></span><br><span class="line">    <span class="built_in">print</span>(browser.find_element(By.LINK_TEXT,<span class="string">&#x27;首页&#x27;</span>).get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="句柄切换"><a href="#句柄切换" class="headerlink" title="句柄切换"></a>句柄切换</h2><p>一个句柄就是一个窗口，如果我们需要进行窗口的切换，就需要使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取所有句柄（以列表形式排列，最新打开的排在最后面）</span></span><br><span class="line">all_handles = browser.window_handles</span><br><span class="line"><span class="comment">#跳转到最后一个句柄</span></span><br><span class="line">browser.switch_to_window(all_handles[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><hr><h2 id="Selenium实现自动抢购"><a href="#Selenium实现自动抢购" class="headerlink" title="Selenium实现自动抢购"></a>Selenium实现自动抢购</h2><p>主要在于<strong>当前时间</strong>与<strong>抢购时间</strong>的不断比较。程序实现时，提前开始抢购，有些页面节点可能还暂时没有出现，可利用<code>find_element</code>返回的布尔值不断循环，注意使用<code>try...except</code>语法增强程序的鲁棒性，如果当前的某个节点（如抢购按钮）还没有出现，就<code>time.sleep(0.001)</code>后继续执行程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本框架</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">br = webdriver.Edge()</span><br><span class="line">br.maximize_window()</span><br><span class="line">br.get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;登录操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">times</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;抢购操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#不断循环获取时间，平均20ms执行一次</span></span><br><span class="line">        now = datetime.datetime.now().strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> now &gt;= times:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> br.find_element(By.ID,<span class="string">&#x27;id&#x27;</span>):</span><br><span class="line">                        br.find_element(By.ID,<span class="string">&#x27;id&#x27;</span>).click()</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;开始结算&quot;</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    time.sleep(<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="针对手机APP的Appium框架"><a href="#针对手机APP的Appium框架" class="headerlink" title="针对手机APP的Appium框架"></a>针对手机APP的Appium框架</h2><h3 id="基本介绍与操作"><a href="#基本介绍与操作" class="headerlink" title="基本介绍与操作"></a>基本介绍与操作</h3><p><strong>Appium</strong>是基于<strong>Selenium</strong>，可实现自动测试，爬虫，自动回复机器人等。它支持多种类型的自动化，包括苹果、安卓应用的原生界面的自动化，以及应用内嵌的<strong>WebView</strong>的自动化（例如微信内嵌的浏览器）。</p><p><strong>Appium</strong>主体为三部分：客户端，服务器端，移动设备。客户端即我们的自动化程序，自动化程序的指令封装在<strong>HTTP</strong>中发送给服务器端，在移动设备上会安装一个<strong>自动化代理程序</strong>，这样服务器端就可以将指令解释为设备听得懂的语言发送给自动化代理程序，由其完成我们的自动化操作。</p><p>操作前的准备工作，需要<strong>JDK</strong>环境，以及<strong>Android</strong> <strong>SDK</strong>环境，需要安装<strong>Appinum</strong>的客户端和服务器端。在准备工作完成后，用USB线连接手机，在<strong>关于手机</strong>中不断点击版本号，打开开发者模式，接着则退出到上级菜单，在开发者模式中，<strong>启动USB调试</strong>。可在终端输入命令<code>adb devices -l</code>来检测是否设备连接成功。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本代码框架</span></span><br><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line">desired_cap = &#123;</span><br><span class="line">    <span class="string">&#x27;platformName&#x27;</span>: <span class="string">&#x27;Android&#x27;</span>,  <span class="comment">#连接的是安卓手机</span></span><br><span class="line">    <span class="string">&#x27;platformVersion&#x27;</span>: <span class="string">&#x27;11&#x27;</span>, <span class="comment">#手机版本</span></span><br><span class="line">    <span class="string">&#x27;deviceName&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="comment">#设备名，主要针对苹果手机，安卓手机随便填写</span></span><br><span class="line">    <span class="string">&#x27;appPackage&#x27;</span>: <span class="string">&#x27;tv.danmaku.bili&#x27;</span>, <span class="comment">#启动APP Package名称</span></span><br><span class="line">    <span class="string">&#x27;appActivity&#x27;</span>: <span class="string">&#x27;ui.splash.SplashActivity&#x27;</span>, <span class="comment">#启动Activity名称，一个Activity相当于一个界面</span></span><br><span class="line">    <span class="string">&#x27;unicodeKeyboard&#x27;</span>: <span class="literal">True</span>, <span class="comment">#需要输入中文的时候填True</span></span><br><span class="line">    <span class="string">&#x27;resetKeyboard&#x27;</span>: <span class="literal">True</span>, <span class="comment">#在用完unicode输入后，还原回原来输入法</span></span><br><span class="line">    <span class="string">&#x27;noReset&#x27;</span>: <span class="literal">True</span>, <span class="comment">#不要重置APP数据（这一项非常重要）</span></span><br><span class="line">    <span class="string">&#x27;newCommandTimeout&#x27;</span>: <span class="number">6000</span>, <span class="comment">#等待时间</span></span><br><span class="line">    <span class="string">&#x27;automationName&#x27;</span>: <span class="string">&#x27;UiAutomator2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#连接Appium Server，第一个参数为服务器地址，这是一个固定的值</span></span><br><span class="line">app = webdriver.Remote(<span class="string">&#x27;http://localhost:4723/wd/hub&#x27;</span>, desired_cap)</span><br></pre></td></tr></table></figure><p>对于<code>appPackage</code>和<code>appActivity</code>两个配置项如何得知呢？需要将连接的手机打开需要测试的应用，然后在终端输入<code>adb shell dumpsys activity recents | find &quot;intent=&#123;&quot;</code>，返回结果的第一行即包含这两个配置项。</p><h3 id="Appium的界面定位"><a href="#Appium的界面定位" class="headerlink" title="Appium的界面定位"></a>Appium的界面定位</h3><p>使用<strong>Appium</strong>定位元素时，和<strong>Selenium</strong>操作基本相同，对于查看界面的工具，可以使用Android SDK中的工具<strong>uiautomatorviewer</strong>,它在SDK目录下的<code>tools/bin</code>中。也可以使用Appium Server自带的界面查看工具。</p><p>定位时依靠的<code>By</code>，由于在移动端有一些特殊的方式，所以略有不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用ID查找时，安卓应用是resource-id，与selenium的id有所不同，但都用By即可</span></span><br><span class="line"><span class="comment">#resource-id并不是唯一的</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">app.find_element(By.ID,<span class="string">&#x27;expand_search&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#安卓应用中的CLASS NAME 类似 selenium 中的Tag NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#根据ACCESSIBILITY_ID</span></span><br><span class="line"><span class="comment">#如果某个元素有content-desc属性，则可以用这个来定位，需要引入AppiumBy</span></span><br><span class="line"><span class="keyword">from</span> appium.webdriver.common.appiumby <span class="keyword">import</span> AppiumBy</span><br><span class="line">app.find_element(AppiumBy.ACCESSIBILITY_ID,<span class="string">&#x27;找人&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="模拟按键"><a href="#模拟按键" class="headerlink" title="模拟按键"></a>模拟按键</h3><p>模拟按键就是在移动设备上，模拟键盘的按键操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium.webdriver.extensions.android.nativekey <span class="keyword">import</span> AndroidKey</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入回车键确定搜索，类似地，也可以像这样使用其他键</span></span><br><span class="line">app.press_keycode(AndroidKey.ENTER)</span><br></pre></td></tr></table></figure><h3 id="其他界面操作"><a href="#其他界面操作" class="headerlink" title="其他界面操作"></a>其他界面操作</h3><p>对于移动设备，我们经常需要<strong>向下滑动页面</strong>才能看到我们想要的元素，而模拟滑动，可以使用方法<code>driver.swipe(start_x, start_y, end_x, end_y, duration)</code>。</p><p>在<strong>Appium</strong>中有一个比较实用的方法，<code>app.tap([(x,y)],duration)</code>可以设置点击页面某个坐标，持续一段时间。</p><p>另外<strong>Appium</strong>的<strong>TouchAction</strong>类提供了更多的手机操作方法，比如：长按、双击、移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appiun.webdriver.common.touch_action <span class="keyword">import</span> TouchAction</span><br><span class="line"><span class="comment">#先生成action对象</span></span><br><span class="line">actions = TouchActions(app)</span><br><span class="line"><span class="comment">#表明要长按哪个页面元素</span></span><br><span class="line">actions.long_press(element)</span><br><span class="line"><span class="comment">#实施操作</span></span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p>如果我们想要打开手机上屏幕顶端的通知栏，那么可以使用<code>driver.open_notifications()</code>操作。如果想要关闭通知栏，则可以使用<strong>模拟按键</strong>中的返回键。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Selenium&lt;/strong&gt;用于实现网页的自动化操作，可跨浏览器使用，也可跨语言使用，在&lt;strong&gt;php&lt;/strong&gt;，&lt;strong&gt;Java&lt;/strong&gt;，&lt;strong&gt;python&lt;/strong&gt;等多门语言中均可使用。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;首先需要安装&lt;strong&gt;selenium&lt;/strong&gt;库，可根据&lt;strong&gt;python&lt;/strong&gt;环境使用&lt;strong&gt;conda&lt;/strong&gt;安装或&lt;strong&gt;pip&lt;/strong&gt;安装，&lt;code&gt;pip install selenium&lt;/code&gt;，安装成功后进入&lt;strong&gt;python&lt;/strong&gt;交互环境，在&lt;code&gt;import selenium&lt;/code&gt;没有报错的情况下，说明安装成功。&lt;/p&gt;
&lt;p&gt;之后还需要为浏览器下载&lt;strong&gt;webdriver&lt;/strong&gt;驱动，在 &lt;a href=&quot;https://www.selenium.dev/downloads/&quot;&gt;Downloads | Selenium&lt;/a&gt; 中找到自己要驱动的浏览器并且下载对应的版本，版本号要与当前浏览器的版本相符，不然会出现启动浏览器后网址会只显示data;，的情况。不过也问题不大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;webdriver&lt;/strong&gt;下载好后的&lt;strong&gt;exe&lt;/strong&gt;文件，可以放在自己的&lt;strong&gt;python&lt;/strong&gt;安装目录下，这是省去了为&lt;strong&gt;webdriver&lt;/strong&gt;配置环境变量的麻烦。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://lw02kx10.github.io/tags/python/"/>
    
    <category term="learn" scheme="https://lw02kx10.github.io/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="https://lw02kx10.github.io/2023/01/19/SQL/"/>
    <id>https://lw02kx10.github.io/2023/01/19/SQL/</id>
    <published>2023-01-19T07:35:21.000Z</published>
    <updated>2023-01-19T13:45:09.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h2><p><strong>SQL</strong>是<strong>结构化查询语言</strong>的缩写 ,是用<strong>SQL</strong>的原因是<strong>内存</strong>是高电压为1，低电压为0，断电后数据不再被存储，所以不保险。</p><blockquote><p><strong>SQL</strong>语言使用了所谓<code>ORM</code>思想即<code>Object Relational Mapping</code>，<strong>一个数据库中有很多表</strong>，每一个表相当于一个<strong>Java</strong>类，每一个表中的记录（行）相当于一个Java类的对象实例，每一个表中的每一列相当于一个<strong>Java</strong>类的属性（或字段field）。</p></blockquote><p><code>DB</code>即数据库，<code>DBMS</code>即数据库管理系统（总管多个数据库），<code>RDBMS</code>即关系型数据库管理系统。</p><p>数据库一共有三种模型：</p><ul><li>层次模型（类树）</li><li>网状模型（类图）</li><li><strong>关系模型（二维表格）（主流数据库）</strong></li></ul><p><strong>非关系型数据库</strong>是关系型数据库的<strong>阉割版本</strong>，基于<strong>键值对</strong>存储数据，不需要经过<code>SQL</code>层的解析，<strong>性能非常高</strong>。</p><span id="more"></span><p><strong>SQL</strong>的分类：</p><blockquote><p><code>DDL</code>:数据定义语言，<strong>CREATE</strong> &#x2F; <strong>ALTER</strong> &#x2F; <strong>DROP</strong> &#x2F; <strong>RENAME</strong> &#x2F; <strong>TRUNCATE</strong></p><p><code>DML</code>:数据操作语言，<strong>INSERT</strong> &#x2F; <strong>DELETE</strong> &#x2F; <strong>UPDATE</strong> &#x2F; <strong>SELECT</strong> 分别对应<strong>增删改查</strong></p><p><code>DCL</code>:数据控制语言，<strong>COMMIT</strong> &#x2F; <strong>ROLLBACK</strong> &#x2F; <strong>SAVEPOINT</strong> &#x2F; <strong>GRANT</strong> &#x2F; <strong>REVOKE</strong></p></blockquote><p>​<strong>COMMIT</strong>表示提交数据，一旦执行，那么数据就被永久地保存在了数据库中，</p><p>​<strong>ROLLBACK</strong>表示撤销，回滚到最近的一次<strong>COMMIT</strong>之后。</p><hr><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="MySQL杂项"><a href="#MySQL杂项" class="headerlink" title="MySQL杂项"></a>MySQL杂项</h3><p>注释方式：<code>#</code>,    <code>-- </code>,    <code>/**/</code></p><p>命令行登录：<code>mysql -uroot -P(端口号) -p -h(主机)</code></p><p>命令行中导入数据库：<code>source + 绝对路径名</code>，然后<code>SHOW DATABASES</code>时就会发现多了一个数据库，就是导入的数据库。</p><p><strong>MySQL</strong>在 Windows 环境下是大小写不敏感的， 在 Linux 环境下是大小写敏感的 。</p><ul><li>数据库名、表名、表的别名、变量名是严格区分大小写的 </li><li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li></ul><p>推荐采用统一的书写规范： 数据库名、表名、表别名、字段名、字段别名等都小写,  <strong>SQL 关键字、函数名、绑定变量</strong>等都大写 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 基本使用</span><br><span class="line">SHOW DATABASES; #列出所有数据库</span><br><span class="line">CREATE DATABASE database1; #创建一个数据库</span><br><span class="line">DROP DATABASE database1; #删除某个数据库</span><br><span class="line">USE database1;  #选择一个数据库</span><br><span class="line">SHOW TABLES;  #列出当前数据库中的所有表</span><br></pre></td></tr></table></figure><h4 id="运算符知识"><a href="#运算符知识" class="headerlink" title="运算符知识"></a>运算符知识</h4><ul><li>在<strong>Java</strong>中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在<strong>MySQL</strong>中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，<strong>如果转失败，就按0计算</strong>。（补充：<strong>MySQL</strong> 中字符串拼接要使用字符串函数<code>CONCAT()</code>实现）  </li><li>在数学运算中，0不能用作除数，在<strong>MySQL</strong>中，一个数除以0为NULL。 </li><li>注意<strong>MySQL</strong>中的等于运算符只有一个<code>=</code>， 如果等号两边的值一个是整数，另一个是字符串，则<strong>MySQL</strong>会将字符串转化为数字进行比较。如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。 <ul><li><strong>SQL</strong>中的赋值语句是<code>:=</code></li></ul></li><li>还有一个<strong>安全</strong>等于运算符<code>&lt;=&gt;</code>，与<code>=</code>的区别是在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL 时，其返回值为0，而不为NULL。 </li><li>不等于运算符<code>&lt;&gt;或者!=</code>不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。</li></ul><hr><h3 id="SELECT语句（查）"><a href="#SELECT语句（查）" class="headerlink" title="SELECT语句（查）"></a>SELECT语句（查）</h3><p><strong>SELECT</strong>语句简单使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*SELECT 语句的简单使用*/</span><br><span class="line"></span><br><span class="line">SELECT 1+1,2*3 FROM DUAL;  </span><br><span class="line">#伪表查询1+1,2*3的值，一种查询常数的方式</span><br><span class="line">SELECT 1 FROM departments;  </span><br><span class="line">#查询departments表的第一列</span><br><span class="line">SELECT id,telephone FROM departments; </span><br><span class="line">#查询列名为id和列名为telephone的那两列</span><br><span class="line"></span><br><span class="line">SELECT last_name (AS) &quot;name&quot;, salary*2 &quot;annual salary&quot; FROM employees; </span><br><span class="line">#在查询的时候给列名起别名，AS关键词可以省略，起的别名最好使用双引号括起来</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT id FROM departments; </span><br><span class="line">#在查询的时候去重</span><br><span class="line"></span><br><span class="line">SELECT salary*2 &quot;annual salary&quot; FROM employees; </span><br><span class="line">#所有运算符或列值遇到null值，运算的结果都为null</span><br><span class="line"></span><br><span class="line">SELECT * FROM `order`; </span><br><span class="line">#在表名为关键字的时候，要使用反引号引住，防止发生歧义，*号为通配符</span><br><span class="line"></span><br><span class="line">SELECT &#x27;China&#x27; AS &quot;country&quot;, last_name &quot;name&quot; FROM employees; </span><br><span class="line">#定义一组常数列，列名为country，这一列的所有值都为China，这列和name列合并到一起</span><br><span class="line"></span><br><span class="line">SELECT name FROM students WHERE score = 100; </span><br><span class="line">#将成绩为100的学生名字过滤出来</span><br></pre></td></tr></table></figure><p>可以用<code>DESC employees</code>显示一个表的结构，呈现出表的<strong>各列的类型，默认值</strong>等等。</p><p><strong>SELECT</strong>语句 + <strong>WHERE</strong>筛选：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*SELECT语句 + WHERE筛选*/</span><br><span class="line"></span><br><span class="line">SELECT id,name FROM employees WHERE name IS NULL;</span><br><span class="line"></span><br><span class="line">SELECT LEAST(1,0,2), LEAST(&#x27;a&#x27;,&#x27;c&#x27;,&#x27;b&#x27;) FROM DUAL; </span><br><span class="line">#选取最小值，当参数中有NULL的时候，返回值为NULL，选择最大值为GREATEST</span><br><span class="line"></span><br><span class="line">SELECT id,name FROM employees WHERE id BETWEEN 100 AND 200; </span><br><span class="line">#筛选出id在[100,200]之间的</span><br><span class="line"></span><br><span class="line">SELECT id,name FROM employees WHERE id IN (100,101,102); </span><br><span class="line">#筛选出id是这三个数的</span><br></pre></td></tr></table></figure><p><strong>LIKE</strong>运算符的模糊匹配规则：</p><blockquote><p>（1）<code>%</code>：匹配0个或多个字符<br>（2）<code>_</code>：只能匹配一个字符</p></blockquote><ul><li>如：匹配所有字符串中含a的字符串：<code>LIKE &quot;%a%&quot;</code></li></ul><p><strong>正则表达式</strong>精确匹配规则：</p><blockquote><p>（1）<code>^</code>匹配以该字符后面的字符<strong>开头</strong>的字符串。<br>（2）<code>$</code>匹配以该字符前面的字符<strong>结尾</strong>的字符串。<br>（3）<code>.</code>匹配任何一个<strong>单字符</strong>。如<code>&quot;b.t&quot;</code>可以匹配’<code>bit&#39;,&#39;bat&#39;,&#39;but&#39;,&#39;bite&#39;</code><br>（4）<code>+</code>匹配前面的字符<strong>至少一次</strong>。如<code>&quot;ba+&quot;</code>可以匹配<code>&#39;battle&#39;</code>，而<code>&quot;ba&#123;3&#125;&quot;</code>则表示匹配a至少3次，而<code>&quot;ba&#123;3,5&#125;&quot;</code>则表示匹配a至少3次,至多5次<br>（5）<code>[...]</code>匹配在方括号内的任何字符。例如，<code>[abc]</code>匹配“a”或“b”或“c”。为了命名字符的范围，使用一。而<code>[^...]</code>则匹配不在括号内的任何字符，<code>&quot;[a-z]&quot;</code>匹配<strong>任何字母</strong>，而<code>“[0-9]”</code>匹配<strong>任何数字</strong>。<br>（6）<code>*</code>匹配<strong>零个或多个在它前面</strong>的字符。例如，<code>x*</code>匹配任何数量的‘x’字符，<code>&quot;[0-9]*&quot;</code>匹配任何数量的数字，而<code>&quot;*&quot;</code>匹配<strong>任何数量的任何字符</strong>。</p></blockquote><ul><li><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;; </span><br><span class="line">#在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录</span><br><span class="line"></span><br><span class="line">SELECT * FROM fruits WHERE f_id REGEXP &#x27;[^a-e1-2]&#x27;</span><br><span class="line">#在fruits表中，查询f_id字段中包含字母a~e和数字1~2以外字符的记录</span><br></pre></td></tr></table></figure></li></ul><p><strong>SELECT</strong>+<strong>ORDER BY</strong>排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM students ORDER BY score; </span><br><span class="line">#默认按升序排列</span><br><span class="line">SELECT id,name FROM students ORDER BY score DESC; </span><br><span class="line">#指定以成绩的降序排列,&#x27;ASC&#x27;是升序</span><br><span class="line"></span><br><span class="line">SELECT id,name FROM students ORDER BY score,id DESC; </span><br><span class="line">#如果成绩相同，那么再按照id进行排序</span><br><span class="line"></span><br><span class="line">SELECT id,name FROM (</span><br><span class="line">SELECT id,name,score FROM students</span><br><span class="line">ORDER BY score DESC;</span><br><span class="line">) WHERE score &gt;= 95;</span><br><span class="line">#结合WHERE和排序进行嵌套查询</span><br></pre></td></tr></table></figure><p><strong>SELECT</strong>+<strong>LIMIT</strong>分页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students LIMIT 0,10; </span><br><span class="line">#返回第1-10行的记录</span><br><span class="line">SELECT * FROM students LIMIT 10,10; </span><br><span class="line">#返回第11-20行的记录</span><br><span class="line"></span><br><span class="line">#分页显示公式：</span><br><span class="line">SELECT * FROM table LIMIT (pageNumber - 1)*pageSize, pageSize; </span><br><span class="line">#pageNumber为要查询的页数，pageSize为分页的每页大小</span><br></pre></td></tr></table></figure><p><strong>多表查询：</strong> 这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有<strong>关联字段</strong>，这个 关联字段可能建立了外键，也可能没有建立外键。比如：<strong>员工表和部门表</strong>，这两个表依靠<strong>“部门编号”</strong>进 行关联。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, department_name FROM employees, departments; </span><br><span class="line">#会出现笛卡尔积</span><br><span class="line"></span><br><span class="line">#用WHERE来避免笛卡尔积：</span><br><span class="line">SELECT last_name, department_name </span><br><span class="line">FROM employees, departments </span><br><span class="line">WHERE employees.department_id = departments.department_id; </span><br><span class="line">#employees和departments有相同的一列就是department_id</span><br><span class="line"></span><br><span class="line">#用表的别名简化查询：需要注意的是，如果我们使用了表的别名，</span><br><span class="line">#在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</span><br><span class="line">SELECT e.employee_id, e.last_name, d.department_id</span><br><span class="line">FROM employees e, departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br><span class="line">#使用JOIN...ON...语法实现上面的代码：</span><br><span class="line">SELECT e.employee_id, e.last_name, d.department_id</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id;</span><br><span class="line">#JOIN表连接，ON表示筛选</span><br><span class="line">#如果需要连接第三个表，则只需要再紧接着跟一个JOIN即可</span><br><span class="line"></span><br><span class="line">#自连接查询时，只需要把一张表重新复制一份，当成两张不同的表来做</span><br><span class="line">SELECT emp.employee_id, emp.employee_name, mgr.employee_name, mgr.employee_id </span><br><span class="line">FROM employees emp, employees mgr </span><br><span class="line">WHERE emp.manager_id = mgr.employee_id;</span><br><span class="line"></span><br><span class="line">#同上，体会一下CONCAT的函数方式</span><br><span class="line">SELECT CONCAT(worker.last_name ,&#x27; works for &#x27;</span><br><span class="line">, manager.last_name)</span><br><span class="line">FROM employees worker, employees manager</span><br><span class="line">WHERE worker.manager_id = manager.employee_id ;</span><br></pre></td></tr></table></figure><p><strong>外连接</strong>知识点：上面做的都是<strong>内连接</strong>，外连接包括<strong>左外连接</strong>和<strong>右外连接</strong>和<strong>满外连接</strong>，如果有左表A和右表B，那么<code>A∪(A ∩ B)</code>是左外连接，<code>A ∩ B</code>是内连接，而<code>A∪B</code>则是满外连接</p><p>使用场景：如左外连接，因为<strong>有的员工可能没有部门</strong>，所以使用内连接那个没有部门的员工出不来，故应该使用外连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.employee_id, e.last_name, d.department_id</span><br><span class="line">FROM employees e LEFT JOIN departments d #右外连接则把LEFT改为RIGHT</span><br><span class="line">ON e.department_id = d.department_id;</span><br><span class="line"></span><br><span class="line">#使用以下语法可以解决满外连接的问题</span><br><span class="line">#UNION:合并并且去重</span><br><span class="line">#UNION ALL:合并但是不去重</span><br><span class="line">#注意：执行UNION ALL语句时所需要的资源比UNION语句少。</span><br><span class="line">#如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/19/tqSmuWza8bnpw3j.png" alt="引用自尚硅谷"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#左中图：</span><br><span class="line">SELECT e.employee_name, d.department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id</span><br><span class="line">WHERE d.department_id IS NULL;</span><br><span class="line"></span><br><span class="line">#左下图：</span><br><span class="line">SELECT e.employee_name, d.department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id</span><br><span class="line">WHERE d.department_id IS NULL;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT e.employee_name, d.department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="单值函数"><a href="#单值函数" class="headerlink" title="单值函数"></a>单值函数</h4><p><strong>数值函数：</strong></p><ul><li><code>ABS()</code>，<code>SIGN()</code>如果是正数返回1，如果是负数返回-1，0返回0。</li><li><code>PI()</code>返回圆周率的值。</li><li><code>CEILING()</code>，<code>FLOOR()</code>。</li><li><code>RAND()</code>返回0-1的随机数。<code>RAND(x)</code>返回0-1的随机数，其中x的值用作种子值，相同的x值会产生相同的随机数，<code>ROUND(x)</code>对x四舍五入后的值,<code>ROUND(x,y)</code>保留到小数点后y位。</li><li><code>TRUNCATE(x,y)</code>对x进行截断，截断到小数点后y位。</li><li><code>SQRT(x)</code>,x为负数的时候返回NULL。</li><li><code>RADIANS(x)</code>把角度转换为弧度，<code>DEGREES(x)</code>把弧度转换为角度。</li><li><code>SIN()</code>,<code>COS()</code>,<code>TAN()</code></li><li><code>POW(x,y)</code>，<code>EXP(x)</code>，<code>LOG(x)</code>以e为对数，<code>LOG2(x),LOG10(x)</code></li><li><code>BIN(x)</code>,<code>HEX(x)</code>,<code>OCT(x)</code>分表表示把x转换为2,16,8进制，<code>CONV(x,f1,f2)</code>把x从f1进制转换为f2进制</li></ul><p><strong>字符串函数：</strong></p><ul><li>注：<strong>MySQL</strong>中的字符串位置是从1开始的</li><li><code>LENGTH(s)</code>返回字节数。</li><li><code>CHAR_LENGTH(s)</code>返回字符个数。</li><li><code>CONCAT(s1,s2,...,sn)</code>，<code>UPPER(s)</code>,<code>LOWER(s)</code>。</li><li><code>REPLACE(str,s1,s2)</code>用s2替换str中的s1。</li><li><code>INSERT(str,idx,len,replacestr)</code>，<code>SUBSTR(str,idx,len)</code>，<code>REVERSE(s)</code></li></ul><p><strong>时间与日期函数：</strong></p><ul><li><code>CURDATE()</code>仅包含年月，<code>CURTIME()</code>仅包含时分秒，<code>NOW()</code>返回当前系统的日期和时间</li><li><code>UNIX_TIMESTAMP()</code>把当前时间转化为时间戳，<code>UNIX_TIMESTAMP(date)</code>把指定时间转换为时间戳，<code>FROM_UNIXTIME(timestamp)</code>把时间戳转换为普通规格的日期时间</li><li><code>YEAR(date)</code>,<code>MONTH(date)</code>,<code>DAY(date)</code>，<code>HOUR(time)</code>,<code>MINUTE(time)</code>,<code>SECOND(time)</code></li><li><code>EXTRACT(type FROM date)</code>返回自己想要返回的时间或者日期类型</li><li><code>TIME_TO_SEC(time)</code>,<code>SEC_TO_TIME(seconds)</code></li><li><code>DATE_FORMAT(date,fmt)</code>,<code>TIME_FORMAT(time,fmt)</code>，<code>STR_TO_DATE(str,fmt)</code>将字符串按照fmt格式进行解析（<strong>fmt</strong>格式需要进行查询）</li></ul><p><strong>流程控制函数：</strong></p><ul><li><code>IF(value1,value2,value3)</code>如果value1为真的话返回value2,否则返回value3</li><li><code>IFNULL(value1,value2)</code>如果value1不为NULL则返回value1，否则返回value2</li><li><code>switch...case</code>类：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT CASE</span><br><span class="line">WHEN num &gt; 1 THEN &#x27;1&#x27;</span><br><span class="line">WHEN num &gt; 0 THEN &#x27;2&#x27;</span><br><span class="line">ELSE &#x27;3&#x27;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">SELECT employee_id,salary, </span><br><span class="line">CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27;</span><br><span class="line">WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;</span><br><span class="line">WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27;</span><br><span class="line">ELSE &#x27;草根&#x27; END &quot;描述&quot;  #注：END后面跟的字符串是自定义的列名</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><p><strong>加密与解密函数：</strong></p><ul><li><code>PASSWORD(str)</code>返回str的加密版本，加密结果<strong>不可逆</strong>，返回一个41位长的字符串，常用于用户的密码加密</li><li><code>MD5(str)</code>用str进行加密，<code>SHA(str)</code>也是一种加密方式，比前者更加安全</li><li><code>ENCODE(value,password_seed)</code>返回使用<code>password_seed</code>作为加密密码加密value</li><li><code>DECODE(vlaue,password_seed)</code>用于解密</li></ul><p><strong>MySQL信息函数：</strong></p><ul><li><code>CONNECTION_ID()</code>返回当前<strong>MySQL</strong>服务器的连接数</li><li><code>DATABASE()</code>返回命令行当前所在的数据库</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;SQL语言概述&quot;&gt;&lt;a href=&quot;#SQL语言概述&quot; class=&quot;headerlink&quot; title=&quot;SQL语言概述&quot;&gt;&lt;/a&gt;SQL语言概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;SQL&lt;/strong&gt;是&lt;strong&gt;结构化查询语言&lt;/strong&gt;的缩写 ,是用&lt;strong&gt;SQL&lt;/strong&gt;的原因是&lt;strong&gt;内存&lt;/strong&gt;是高电压为1，低电压为0，断电后数据不再被存储，所以不保险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;SQL&lt;/strong&gt;语言使用了所谓&lt;code&gt;ORM&lt;/code&gt;思想即&lt;code&gt;Object Relational Mapping&lt;/code&gt;，&lt;strong&gt;一个数据库中有很多表&lt;/strong&gt;，每一个表相当于一个&lt;strong&gt;Java&lt;/strong&gt;类，每一个表中的记录（行）相当于一个Java类的对象实例，每一个表中的每一列相当于一个&lt;strong&gt;Java&lt;/strong&gt;类的属性（或字段field）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;DB&lt;/code&gt;即数据库，&lt;code&gt;DBMS&lt;/code&gt;即数据库管理系统（总管多个数据库），&lt;code&gt;RDBMS&lt;/code&gt;即关系型数据库管理系统。&lt;/p&gt;
&lt;p&gt;数据库一共有三种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;层次模型（类树）&lt;/li&gt;
&lt;li&gt;网状模型（类图）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关系模型（二维表格）（主流数据库）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;非关系型数据库&lt;/strong&gt;是关系型数据库的&lt;strong&gt;阉割版本&lt;/strong&gt;，基于&lt;strong&gt;键值对&lt;/strong&gt;存储数据，不需要经过&lt;code&gt;SQL&lt;/code&gt;层的解析，&lt;strong&gt;性能非常高&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="learn" scheme="https://lw02kx10.github.io/tags/learn/"/>
    
    <category term="SQL" scheme="https://lw02kx10.github.io/tags/SQL/"/>
    
  </entry>
  
</feed>
